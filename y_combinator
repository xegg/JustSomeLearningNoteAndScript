一步一步讲解Y组合子 (Y-Combinator Explained Step by Step)
你也许听说过Y组合子（又叫Y Combinator），也查过一些资料看过一些示例代码，但就是不明白什么意思，可能是因为自己平常使用的开发语言先入为主阻碍了对函数式独特的运算规则和一些细节没想清楚。
一：Lambda演算（Lambda Calculus）
Lambda又写作希腊字母λ，Lambda演算由Alonzo Church引入以定义“可计算函数”。该演算影响了一系列所谓函数式编程语言，如Lisp、ML系列。
一个Lambda表达式用以下格式定义：
λ变量.表达式体
Scheme里要这么写：
(lambda (变量)
  表达式体)
比如，传入一个数后返回加1的结果，Lambda表达式写作：
λa.a+1
Scheme可以写作：
(lambda (a)
  (+ a 1))
当然，变量可以是多个，比如求两个数之和的Lambda表达式可以写作：
λa b.a+b
用Scheme语言可以写作：
(lambda (a b)
  (+ a b))
原始的Lambda演算甚至连逻辑和算术运算和数字都没有，所有的一切都是可以用Lambda演算定义出来的，当然在现代的编程语言中没必要做到那么“纯粹”，包括各种数据类型和运算该用都能用。
比如判断一个数字是否大于3，Scheme里写作：
(lambda (a)
  (if (> a 3)
    "Yes"
    "No"))
具体Lambda函数是怎么工作的呢，答案是归约。
归约有三种规则：
α-转换(α-conversion)
α读作alpha。alpha转换的意思是变量名不影响函数含义的意思。比如：
λa b.a+b
把变量名的a和b换为x和y：
λx y.x+y
该函数的功能并没有发生改变，不管传哪两个数字进去，都会得到一样的结果即两者的和。
β归约(β-reduction)
β读作beta。beta归约的规则是把函数“应用”到传入的参数上。
比如这么个Lambda函数：
λa b.a+b
应用在传入的两个参数1和2，那么a和b分别就替换成1和2，表达式体中的a和b的位置也分别被替换成1和2：
1+2
结果为3.
Scheme该这么写：
((lambda (a) (+ a b)) 1 2)
η变换(η-conversion)
β读作eta，eta转换表达的意思是，如果两个函数对于所有相同的传入的参数都能得到一样的结果，则两个函数相等。
二：循环与递归
现在看一个稍微复杂一点的问题，假设要求n!，也就是1*2*3*4*5*...*n该如何编写程序？
一种想法用所谓循环，比如用最常见的C语言，可以这么写：
int i;
int s = 1;
for (i = 1; i != n; i++)
{
  s *= i;
}
但是普通的函数式语言是不提倡甚至不允许这么写的，原因就在于上面的写法有一个保存状态的行为，也就是给一些变量赋值，保存了中间结果，而函数式语言则基于Lambda演算，Lambda演算可没有“保存状态”这种行为。
你可能会想到使用递归来实现类似循环的效果，比如Scheme里:
(define factorial
  (lambda (n)
    (if (> n 0) 
        (* n (factorial (- n 1)))
        1)))
这样做运行起来是没有问题的，可是我们给这个函数绑定了一个名字Lambda运算本身不支持这种做法，也就是说第一行得擦掉
(lambda (n)
  (if (> n 0) 
      (* n (factorial (- n 1)))
      1))
但是这样factorial则不再存在了，调用它是不会有结果的，我们只能调用点别的东西：
(lambda (n)
  (if (> n 0) 
      (* n (??? (- n 1)))
      1))
此时对于常用普通的非函数式语言的程序员比较费解的一点来了，就是函数也是一种“值”或者“对象”，它不但可以绑定到一个变量上，而且还能调用某函数时作为实际参数传入、并且在被调用的函数内部通过参数列表绑定的名字把传入的函数取出来。这么听上去似乎和函数指针之类的东西比较也没什么了不起，但是流行的函数式语言或者常被用于举例解释Y-Combinator的函数式语言往往是动态类型的或者有一定类型推导能力的，写起来十分简洁，看上去就似乎特别神奇。
以Scheme为例，定义一个返回两数和函数是：
(define (add a b)
  (+ a b))
但是这只是一种缩略的写法，Scheme里所有函数都是Lambda函数，本质上它等同于:
(define add
  (lambda (a b)
    (+ a b)))
含义是，有那么个Lambda函数，功能是返回两数的和，然后把这个函数绑定在add这个变量上，或者说“赋值”给add变量。
我们可以直接调用这个add函数：
(add 1 2)
但是实际上add不是这个函数，只是这个函数绑定的名字，实际执行时会根据绑定的名字取出原来的Lambda函数：
((lambda (a b)
    (+ a b)) 1 2)
然后把函数应用在1和2上，得到结果3
还可以把一个函数作为参数传给另一个函数：
(define (foo f)
  (f 1 2))
(define add
  (lambda (a b)
    (+ a b)))
(foo add)
这个程序就是把add函数作为参数传给foo函数，foo函数内部则取出绑定在f变量的传入的add函数，将该函数应用在1和2上，执行得到3后返回。
当然我们传入的函数不一定要绑定add这个名字，直接传入lambda函数也是一样的效果：
(define (foo f)
  (f 1 2))
(foo (lambda (a b)
    (+ a b)))
既然能把Lambda传入一个绑定名字的函数，那能不能不要绑定名字而是直接把Lambda函数传递到另一个Lambda函数中呢？当然可以。我们可以看到上面的foo函数本质上就是Lambda函数，也就是：
(define (foo f)
  (f 1 2))
和：
(define foo
  (lambda (f)
    (f 1 2)))
是等价的。我们继续做上面做过的类似C语言的inline操作，也就是手工把函数“展开”，可以得到
((lambda (f)
    (f 1 2)) (lambda (a b)
    (+ a b)))
此时原本清晰的程序已经非常难看了，但是运行的结果也是一样的。经过上面这一系列示例，你对Lambda演算有初步的概念了吗？
三：传入自己
回到之前的求阶乘的问题上：
(lambda (n)
  (if (> n 0) 
      (* n (??? (- n 1)))
      1))
lambda变量里不能调用一个外部的绑定名字的函数，当然Lambda函数本身也不能有名字（所以在某些编程语言里Lambda函数这个概念又叫做“匿名函数”）,既然自己没有名字那如何调用自己呢？通过上一节的讨论结论很明显了，就是把“自己”或者说跟自己功能一样的函数作为参数传给自己，然后自己就可以从参数列表中取出“自己”或者说跟自己功能一样的函数进行调用。
程序修改为：
(lambda (f)
  (lambda (n)
    (if (= n 0)
        1
        (* n (f (- n 1))))))
其中f为“跟‘自己’功能一样的函数”，上面写的函数是阶乘函数吗？不是，他本身是一个Lambda函数，接受了一个f参数，并且返回了一个使用f参数的Lambda函数。有人觉得很奇怪为什么返回的另一个函数居然能使用f这个参数，这就涉及函数式编程语言中流行的另一个概念，叫“闭包”。关于闭包的更多信息请参考**这篇文章**。可见，以上的函数不是阶乘函数而是“阶乘函数生成器”，为了方便下面解释暂时绑定一个名字。
(define factorial-maker
  (lambda (f)
    (lambda (n)
      (if (= n 0)
          1
          (* n (f (- n 1)))))))
那么传入的“跟自己功能一样的函数”是一个什么样的函数呢？是一个阶乘函数，阶乘函数的写法是：
(define factorial
  (lambda (n)
    (if (= n 0)
        1
        (* n (factorial (- n 1))))))
但是慢着，factorial函数可不能调用自己啊，那不能调用自己调用谁呢？可以调用之前写的“阶乘生成器”，于是阶乘函数改为：
(define factorial
  (lambda (n)
    (if (= n 0)
        1
        (* n ((factorial-maker factorial) (- n 1))))))
这里用到的参数factorial还是不存在的，那么如何得到factorial呢？还是得调用factorial-maker产生：
(define factorial
  (lambda (n)
    (if (= n 0)
        1
        (* n ((factorial-maker (factorial-maker factorial)) (- n 1))))))
这似乎要无数次调用factorial-maker，没完没了……
四：不动点
从上一节引出的问题是，虽然factorial-maker能生成factorial，但是还是需要以factorial作为参数传入，而这与转而使用factorial-maker的目的相违背，所以我们得引入一个概念，叫“不动点”。
不动点的概念以前大家都应该接触过，维基百科里解释“在数学中，函数的不动点或定点是指被这个函数映射到其自身一个点。”
举例解释，比如函数：
f(x) = x * x
当x分别为0或1时，函数的值也分别为0或1即原来的数，则0和1为函数f的不动点，也就是：
x = f(x) = f(f(x)) = f(f(f(x)))
在编程语言里，这个概念又要进一步扩展，因为函数也可以作为输入。
假设有函数f(fn)，fn为函数f的输入参数，并且
fn = f(fn)
很容易发现f应用在fn上不管多少次，结果都一样：
fn = f(fn) = f(f(fn)) = f(f(f(fn)))
函数可以作为参数传递、返回值也可以是个函数，说起来容易但是对于平常不使用“函数式语言”的程序员理解起来总是不太顺畅。
五：Y函数
有了不动点的概念，再考虑上面的问题，我们有了factorial-maker，也就是可以生成factorial的函数，但是需要的是factorial本身作为参数传入，那么如何获得factorial本身？假设我们有一个函数叫Y，这个函数的作用是输入一个函数的生成器也就是factorial-maker输出该函数本身如factorial：
factorial = Y(factorial-maker)   (1)
用Scheme的语法写作(Y factorial-maker)可以得到我们想要的factorial。而且：
factorial = factorial-maker(factorial) = factorial-maker(factorial-maker(factorial)) =  (2)
对于函数factorial应用任意次factorial-maker函数，都得到factorial本身，说明factorial本身是函数factorial-maker的不动点。
结合(1)和(2)可以得到：
Y(factorial-maker) = factorial-maker(factorial) (3)
(1)代入(3)的右边得到：
Y(factorial-maker) = factorial-maker(Y(factorial-maker))
于是我们需要的Y就出来了，用Scheme语言写出来就是：
(define Y
  (lambda (f)
    (f (Y f))))
整个程序则为：
(define Y
  (lambda (f)
    (f (Y f))))
(define factorial-maker
  (lambda (f)
    (lambda (n)
      (if (= n 0)
          1
          (* n (f (- n 1)))))))
(display ((Y factorial-maker) 5))
这个程序从字面上是正确的，但一旦运行则会根据运行环境的不同有不同的运行结果，卡死直至消耗完计算机资源、提示栈溢出、运行得到正确的120，都是有可能的。原因在于Y函数内部的Lambda函数可能会调用Y不断增加新的栈帧，还来不及执行函数f。
当然一个更明显的问题是，这个程序仍然没有仅仅借用Lambda运算完成重复的操作。
六：Y函数（改进）
接下来的推导就比较困难了，我现在还没能完全弄清楚怎么到我们常见的最终形式。
Y组合子常见的最终形式是：
Y = λf.(λx.f (x x)) (λx.f (x x))
用Scheme写出来则是：
(define y-combinator
  (lambda (f)
    ((lambda (x) (f (lambda (y) ((x x) y))))
     (lambda (x) (f (lambda (y) ((x x) y)))))))
这个最终形式的Y组合子可以工作在非Lazy的正确实现的Scheme里。
七：用途
在“大多数”普通的命令式编程语言里、甚至某些支持函数式编程的不标榜函数式的编程语言里，的确很难想象到为什么表达一个重复的过程，非得求助于Y，正如前面的例子所描述，绑定一个名字往往就可以直接解决问题。不过大部分函数式编程语言既然构建在Lambda演算的基础上，底层通常也是把我们看到的高级语言的假象展开为Lambda演算，对于这些编程语言的实现者来说Y组合子是实现一些特殊语法的必要设施。
参考资料：
Lambda calculus：http://en.wikipedia.org/wiki/Lambda_calculus
不动点：http://zh.wikipedia.org/wiki/%E4%B8%8D%E5%8A%A8%E7%82%B9



函数式编程的 Y Combinator 有哪些实用价值？修改
之前看到有篇文章在微博上被好些人分享, 就对文档频繁的关键此产生了兴趣
"康托尔、哥德尔、图灵——永恒的金色对角线(rev#2) http://mindhacks.cn/2006/10/15/cantor-godel-turing-an-eternal-golden-diagonal/ "
然后今天去搜相关的博文, 这东西真是玄了.. 很想去看懂
http://minus273.eu/mirrors/2001315450/wiki/SchemeYcombinator.html
http://lifegoo.pluskid.org/?p=203=1
http://jisedai.vayn.de/2011/07/17/deriving-the-y-combinator.html
那么 Y Combinator 究竟能带来什么样的能力呢?修改
举报 8 条评论 分享 • 邀请回答
按投票排序
按时间排序
9 个回答

31
赞同反对，不会显示你的姓名

lemon cherry
31 人赞同
一句话解释： Y Combinator 用于计算（高阶）函数的不动点，使得lambda演算可以定义匿名递归函数。

下面是具体的解释：

所谓lambda演算是一种计算模型，在这种计算模型中，一切都是函数，连数值都可以没有（可以用函数表示）。它具有和图灵机等价的计算能力，但是和图灵机偏硬件的描述方式不同，lambda演算（基本上）只依赖两条数学推理规则。

虽然lambda演算中一切都是函数，但都可以不需要函数名。没有函数名的函数称为「匿名函数」。lambda符号的引入就是为了去掉函数名这个冗余，使定义匿名函数成为可能。比如平方函数 sqr (x) = x * x 在lambda演算中写成 lambda x . x * x，表明对参数 x 执行自己乘以自己的操作。任何用到 sqr (x) 的地方，直接用这个lambda式子替换就可以。但是当需要定义的函数含有递归时，比如阶乘 factorial，我们习惯的方式是 

factorial (x) = (x == 0) ? 1 : x * factorial (x - 1)

直接写成lambda演算则是

factorial (x) = lambda x . (x == 0) ? 1 : x * factorial (x - 1)

这时候函数的定义部分引用了函数自身，但是，没有函数名意味着用无法直接引用函数自身。怎么办呢？

一种办法是使用高阶函数，所谓高阶函数是指这样的一种函数，它接受一个函数作为参数，返回值也是一个函数。具体思路是：构造高阶函数G，使它满足 G(factorial) = factorial。这样我们就不用直接定义factorial，求解这个关于G的方程就可以得到factorial的定义了。

于是，我们需要干两件事：找到G，和找到求解 G(f)=f 的办法。寻找G很简单，既然我们想让G(factorial) = factorial，那么把上面factorial定义中关于factorial的引用参数化就可以了，即：

G(f(x)) = lambda f . lambda x . (x == 0) ? 1 : x * f (x - 1)

函数G接受参数 f(x) ，输出是一个参数为 x 的函数，而它的定义中没有关于自身的引用。实际上，这种构造方法可以用于构造任意递归函数的「G」。

求解方程 G(f)=f 的办法就是使用Y Combinator。满足 f(x) = x 的 x 称为函数 f 的不动点，即使 f 是高阶函数时也不例外。Y Combinator也是高阶函数，其作用就是计算函数的不动点，它对所有的函数 f 都满足 f( Y(f) ) = Y(f)。

于是，factorial的定义就可以写成：factorial (x) = Y G x，这下不用引用自身了。
编辑于 2014-12-09 4 条评论 感谢 分享 收藏 • 没有帮助 • 举报 • 作者保留权利

温悦
I am pf_miles@Alibaba.
黄继新、 涛吴 等 181 人赞同
在08年的时候(这经历记忆犹新)我也跟LZ一样，翻了好多文章，google了好几个星期，最后我知道它是这么个东西：
它是函数式编程的理论基础：lambda演算的一部分，而并非一个“实用”的东西，也就是说，你在实际编程过程中碰不到它——你该用循环的时候就用循环，该用递归的时候就用递归，Y组合子在哪里？？你不需要知道，因为它并不是一个"用于编程的元素"，它只是lambda演算要实现逻辑的完备而产生出来的一个"工具"
如果LZ关注过“可计算性”或者“计算科学”方面的知识，就知道：跟图灵机具有相同计算能力的另外一种更加简单的计算模型叫做“lambda演算”，也就是说，lambda演算也是“图灵完备”的；且，也就是说，如果能够依据图灵机模型而构造出现代计算机的硬件体系结构的话，同样也能根据lambda演算，创造一种计算机硬件；再，也就是说，图灵机模型能解决的问题，lambda演算也一定能解决，反之亦然
lambda演算是一个很优美的模型，它远比图灵机纸带模型简单（它只有alpha变换和beta规约两种操作），但却有着和图灵机相同的能力；但光数学上证明这一点还不甘心，于是呢，就真有人开始试着用lambda演算构建一个完整的形式逻辑系统，比如著名的“邱奇计数法(church numeral请google之)”，用来定义0、1、2...加减乘除...true or false布尔逻辑...等等等等...这样继续下去之后，很快就遇到一个棘手的问题：lambda演算如何定义递归(或者说循环)
学计算机的人一定从教科书上了解到：函数“递归”的意思就是一个函数“直接或间接地调用自身”(循环其实也一样，循环可以归结为“尾递归”，下文就不说“循环”了，统一说“递归”)；通常的理解就是——在函数内部call了自己的“名字”，但是原生的lambda演算里面的组合子都没有“名字”，那么如何调用到自己呢？那么，问题也就归结成：“如何构建一个匿名递归函数”
Y组合子的形式想必LZ也看过了，我在这里就不做定量的公式演算了，网上已经有太多的文章做了这样的演算，可以找来看；我只想说明一下这些演算的意义：Y组合子又叫“不动点组合子”，“不动点”的概念或许在高中就接触过，但高中时期的不动点，就是一个数字而已，这里“不动点组合子”里面的“不动点”指的是“高阶函数(懂函数式编程应该知道这个概念)”的不动点，它并不是一个单纯的数字，而是一个“函数”(其实单纯的数字也可以看作一个函数，只不过是一个没有x自变量的函数，在坐标轴上是一条水平线...不过说这个的话就偏题了:-))；好了，既然Y组合子是一个高阶函数，那么它也就是需要“接受一个函数，返回一个函数”了，那么Y组合子刚好有这样一种魔力：它接受一个函数，返回的是这个函数的不动点...
好了，那么如何使用这个“魔力”实现递归呢？回想一下“函数的递归就是函数直接或间接地调用自身”；关键是“间接”二字，在没有名字的情况下如何间接调用自身？那么Y组合子给出的方案就是：把“自己”“算出来”；
那么总结就是：Y组合子是用作给那些没有名字的函数“把自己给算出来，方便自己调用自己”而创造的；它从实践上证明了“图灵机模型能表达递归，lambda演算同样也能”的道理，属于“为lambda演算等价于图灵机”这一理论的一个理论支撑；就是这样，它是理论层面的东西，你在平时编程中看不到它；它只奢求你在用lisp写出一个递归函数的时候能想念起它就行了...
当然，现在我们用的lisp底层并非真的由Y组合子实现：它真正的实现是基于图灵机模型实现的——因为我们的计算机根本就不是根据lambda演算理论构建的，但由于图灵机模型跟lambda计算是等价的，所以在我们冯氏计算机体系结构上实现lisp这种函数式语言也是完全可行的。(假设人类当初是按照lambda演算的原理来制造计算机的，那么在其上实现c语言也是完全理论可行的，基于同样的道理)
