基于用户投票的排名算法（一）：Delicious和Hacker News
作者： 阮一峰
日期： 2012年2月24日
互联网的出现，意味着"信息大爆炸"。
用户担心的，不再是信息太少，而是信息太多。如何从大量信息之中，快速有效地找出最重要的内容，成了互联网的一大核心问题。

各种各样的排名算法，是目前过滤信息的主要手段之一。对信息进行排名，意味着将信息按照重要性依次排列，并且及时进行更新。排列的依据，可以基于信息本身的特征，也可以基于用户的投票，即让用户决定，什么样的信息可以排在第一位。
下面，我将整理和分析一些基于用户投票的排名算法，打算分成六个部分连载，今天是第一篇。
一、Delicious
最直觉、最简单的算法，莫过于按照单位时间内用户的投票数进行排名。得票最多的项目，自然就排在第一位。
旧版的Delicious，有一个"热门书签排行榜"，就是这样统计出来的。

它按照"过去60分钟内被收藏的次数"进行排名。每过60分钟，就统计一次。
这个算法的优点是比较简单、容易部署、内容更新相当快；缺点是，一方面，排名变化不够平滑，前一个小时还排名靠前的内容，往往第二个小时就一落千丈，另一方面，缺乏自动淘汰旧项目的机制，某些热门内容可能会长期占据排行榜前列。
二、Hacker News
Hacker News是一个网络社区，可以张贴链接，或者讨论某个主题。

每个帖子前面有一个向上的三角形，如果你觉得这个内容很好，就点击一下，投上一票。根据得票数，系统自动统计出热门文章排行榜。但是，并非得票最多的文章排在第一位，还要考虑时间因素，新文章应该比旧文章更容易得到好的排名。
Hacker News使用Paul Graham开发的Arc语言编写，源码可以从arclanguage.org下载。它的排名算法是这样实现的：

将上面的代码还原为数学公式：

其中，
　　P表示帖子的得票数，减去1是为了忽略发帖人的投票。
　　T表示距离发帖的时间（单位为小时），加上2是为了防止最新的帖子导致分母过小（之所以选择2，可能是因为从原始文章出现在其他网站，到转贴至Hacker News，平均需要两个小时）。
　　G表示"重力因子"（gravityth power），即将帖子排名往下拉的力量，默认值为1.8，后文会详细讨论这个值。
从这个公式来看，决定帖子排名有三个因素：
第一个因素是得票数P。
在其他条件不变的情况下，得票越多，排名越高。

从上图可以看到，有三个同时发表的帖子，得票分别为200票、60票和30票（减1后为199、59和29），分别以黄色、紫色和蓝色表示。在任一个时间点上，都是黄色曲线在最上方，蓝色曲线在最下方。
如果你不想让"高票帖子"与"低票帖子"的差距过大，可以在得票数上加一个小于1的指数，比如(P-1)^0.8。
第二个因素是距离发帖的时间T。
在其他条件不变的情况下，越是新发表的帖子，排名越高。或者说，一个帖子的排名，会随着时间不断下降。
从前一张图可以看到，经过24小时之后，所有帖子的得分基本上都小于1，这意味着它们都将跌到排行榜的末尾，保证了排名前列的都将是较新的内容。
第三个因素是重力因子G。
它的数值大小决定了排名随时间下降的速度。

从上图可以看到，三根曲线的其他参数都一样，G的值分别为1.5、1.8和2.0。G值越大，曲线越陡峭，排名下降得越快，意味着排行榜的更新速度越快。
知道了算法的构成，就可以调整参数的值，以适用你自己的应用程序。
[参考文献]
　　* How Hacker News ranking algorithm works
　　* How to Build a Popularity Algorithm You can be Proud of


基于用户投票的排名算法（三）：Stack Overflow
作者： 阮一峰
日期： 2012年3月11日
上一篇文章，我介绍了Reddit的排名算法。
它的特点是，用户可以投赞成票，也可以投反对票。也就是说，除了时间因素以外，只要考虑两个变量就够了。
但是，还有一些特定用途的网站，必须考虑更多的因素。世界排名第一的程序员问答社区Stack Overflow，就是这样一个网站。

你在上面提出各种关于编程的问题，等待别人回答。访问者可以对你的问题进行投票（赞成票或反对票），表示这个问题是不是有价值。

一旦有人回答了你的问题，其他人也可以对这个回答投票（赞成票或反对票）。

排名算法的作用是，找出某段时间内的热点问题，即哪些问题最被关注、得到了最多的讨论。
在Stack Overflow的页面上，每个问题前面有三个数字，分别表示问题的得分、回答的数目和该问题的浏览次数。以这些变量为基础，就可以设计算法了。

创始人之一的Jeff Atwood，曾经在几年前，公布过排名得分的计算公式。

写成php代码，就是下面这样：

各个算法变量的含义如下：
（1）Qviews（问题的浏览次数）
　　
某个问题的浏览次数越多，就代表越受关注，得分也就越高。这里使用了以10为底的对数，用意是当访问量越来越大，它对得分的影响将不断变小。
（2）Qscore（问题得分）和Qanswers（回答的数量）
　　
首先，Qscore（问题得分）= 赞成票-反对票。如果某个问题越受到好评，排名自然应该越靠前。
Qanswers表示回答的数量，代表有多少人参与这个问题。这个值越大，得分将成倍放大。这里需要注意的是，如果无人回答，Qanswers就等于0，这时Qscore再高也没用，意味着再好的问题，也必须有人回答，否则进不了热点问题排行榜。
（3）Ascores（回答得分）
　　
一般来说，"回答"比"问题"更有意义。这一项的得分越高，就代表回答的质量越高。
但是我感觉，简单加总的设计还不够全面。这里有两个问题。首先，一个正确的回答胜过一百个无用的回答，但是，简单加总会导致，1个得分为100的回答与100个得分为1的回答，总得分相同。其次，由于得分会出现负值，因此那些特别差的回答，会拉低正确回答的得分。
（4）Qage（距离问题发表的时间）和Qupdated（距离最后一个回答的时间）
　　
改写一下，可以看得更清楚：
　　
Qage和Qupdated的单位都是秒。如果一个问题的存在时间越久，或者距离上一次回答的时间越久，Qage和Qupdated的值就相应增大。
也就是说，随着时间流逝，这两个值都会越变越大，导致分母增大，因此总得分会越来越小。
（５）总结
Stack Overflow热点问题的排名，与参与度（Qviews和Qanswers）和质量（Qscore和Ascores）成正比，与时间（Qage和Qupdated）成反比。


基于用户投票的排名算法（二）：Reddit
作者： 阮一峰
日期： 2012年3月 7日
（不好意思，这个系列中断了近两周，我会尽快在这几天，把后面几篇写完。）
上一次，我介绍了Hacker News的排名算法。它的特点是用户只能投赞成票，但是很多网站还允许用户投反对票。就是说，除了好评以外，你还可以给某篇文章差评。

Reddit是美国最大的网上社区，它的每个帖子前面都有向上和向下的箭头，分别表示"赞成"和"反对"。用户点击进行投票，Reddit根据投票结果，计算出最新的"热点文章排行榜"。
怎样才能将赞成票和反对票结合起来，计算出一段时间内最受欢迎的文章呢？如果文章A有100张赞成票、5张反对票，文章B有1000张赞成票、950张反对票，谁应该排在前面呢？
Reddit的程序是开源的，使用Python语言编写。排名算法的代码大致如下：

这段代码考虑了这样几个因素：
（1）帖子的新旧程度t
　　t = 发贴时间 - 2005年12月8日7:46:43
t的单位为秒，用unix时间戳计算。不难看出，一旦帖子发表，t就是固定值，不会随时间改变，而且帖子越新，t值越大。至于2005年12月8日，应该是Reddit成立的时间。
（2）赞成票与反对票的差x
　　x = 赞成票 - 反对票
（3）投票方向y
　　
y是一个符号变量，表示对文章的总体看法。如果赞成票居多，y就是+1；如果反对票居多，y就是-1；如果赞成票和反对票相等，y就是0。
（4）帖子的受肯定（否定）的程度z
　　
z表示赞成票与反对票之间差额的绝对值。如果对某个帖子的评价，越是一边倒，z就越大。如果赞成票等于反对票，z就等于1。
结合以上几个变量，Reddit的最终得分计算公式如下：
　　
这个公式可以分成两个部分来讨论：
（一）
　　
这个部分表示，赞成票与反对票的差额z越大，得分越高。
需要注意的是，这里用的是以10为底的对数，意味着z=10可以得到1分，z=100可以得到2分。也就是说，前10个投票人与后90个投票人（乃至再后面900个投票人）的权重是一样的，即如果一个帖子特别受到欢迎，那么越到后面投赞成票，对得分越不会产生影响。
当赞成票等于反对票，z=1，因此这个部分等于0，也就是不产生得分。
（二）
　　
这个部分表示，t越大，得分越高，即新帖子的得分会高于老帖子。它起到自动将老帖子的排名往下拉的作用。
分母的45000秒，等于12.5个小时，也就是说，后一天的帖子会比前一天的帖子多得2分。结合前一部分，可以得到结论，如果前一天的帖子在第二天还想保持原先的排名，在这一天里面，它的z值必须增加100倍（净赞成票增加100倍）。
y的作用是产生加分或减分。当赞成票超过反对票时，这一部分为正，起到加分作用；当赞成票少于反对票时，这一部分为负，起到减分作用；当两者相等，这一部分为0。这就保证了得到大量净赞成票的文章，会排在前列；赞成票与反对票接近或相等的文章，会排在后面；得到净反对票的文章，会排在最后（因为得分是负值）。
（三）
这种算法的一个问题是，对于那些有争议的文章（赞成票和反对票非常接近），它们不可能排到前列。假定同一时间有两个帖子发表，文章A有1张赞成票（发帖人投的）、0张反对票，文章B有1000张赞成票、1000张反对票，那么A的排名会高于B，这显然不合理。
结论就是，Reddit的排名，基本上由发帖时间决定，超级受欢迎的文章会排在最前面，一般性受欢迎的文章、有争议的文章都不会很靠前。这决定了Reddit是一个符合大众口味的社区，不是一个很激进、可以展示少数派想法的地方。




基于用户投票的排名算法（四）：牛顿冷却定律
作者： 阮一峰
日期： 2012年3月16日
这个系列的前三篇，介绍了Hacker News，Reddit和Stack Overflow的排名算法。
今天，讨论一个更一般的数学模型。
这个系列的每篇文章，都是可以分开读的。但是，为了保证所有人都在同一页上，我再说一下，到目前为止，我们用不同方法，企图解决的都是同一个问题：根据用户的投票，决定最近一段时间内的"热文排名"。
你可能会觉得，这是一个全新的课题，伴随着互联网而产生，需要全新的方法来解决。但是，实际上不是。我们可以把"热文排名"想象成一个"自然冷却"的过程：
　　（1）任一时刻，网站中所有的文章，都有一个"当前温度"，温度最高的文章就排在第一位。
　　（2）如果一个用户对某篇文章投了赞成票，该文章的温度就上升一度。
　　（3）随着时间流逝，所有文章的温度都逐渐"冷却"。
　　
这样假设的意义，在于我们可以照搬物理学的冷却定律，使用现成的公式，建立"温度"与"时间"之间的函数关系，轻松构建一个"指数式衰减"（Exponential decay）的过程。

伟大的物理学家牛顿，早在17世纪就提出了温度冷却的数学公式，被后人称作"牛顿冷却定律"（Newton's Law of Cooling）。我们就用这个定律构建排名算法。

"牛顿冷却定律"非常简单，用一句话就可以概况：
物体的冷却速度，与其当前温度与室温之间的温差成正比。
写成数学公式就是：
　　
其中，
　　- T(t)是温度（T）的时间（t）函数。微积分知识告诉我们，温度变化（冷却）的速率就是温度函数的导数T'(t)。
　　- H代表室温，T(t)-H就是当前温度与室温之间的温差。由于当前温度高于室温，所以这是一个正值。
　　- 常数α（α>0）表示室温与降温速率之间的比例关系。前面的负号表示降温。不同的物质有不同的α值。
这是一个微分方程，为了计算当前温度，需要求出T(t)的函数表达式。
第一步，改写方程，然后等式两边取积分。
　　
　　

第二步，求出这个积分的解（c为常数项）。
　　
　　
　　
第三步，假定在时刻t0，该物体的温度是T(t0)，简写为T0。代入上面的方程，得到
　　
　　
第四步，将上一步的C代入第二步的方程。
　　
假定室温H为0度，即所有物体最终都会"冷寂"，方程就可以简化为
　　
上面这个方程，就是我们想要的最终结果：
　　本期温度 = 上一期温度 x exp(-(冷却系数) x 间隔的小时数)
将这个公式用在"排名算法"，就相当于（假定本期没有增加净赞成票）
　　本期得分 = 上一期得分 x exp(-(冷却系数) x 间隔的小时数)
其中，"冷却系数"是一个你自己决定的值。如果假定一篇新文章的初始分数是100分，24小时之后"冷却"为1分，那么可以计算得到"冷却系数"约等于0.192。如果你想放慢"热文排名"的更新率，"冷却系数"就取一个较小的值，否则就取一个较大的值。

[参考文献]
　　*　Rank Hotness With Newton's Law of Cooling
（完）
