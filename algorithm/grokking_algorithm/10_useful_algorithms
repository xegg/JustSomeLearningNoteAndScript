When a user logs in to Facebook, Facebook
has to look through a big array to see if the
username exists. We said the fastest way to
search through this array is to run binary
search. But there’s a problem: every time a new
user signs up, you insert their username into
the array. Then you have to re-sort the array,
because binary search only works with sorted
arrays.

If you’re interested in databases or more-advanced data structures,
check these out:
• B-trees
• Red-black trees
• Heaps
• Splay trees


Inverted indexes
Let’s build a hash table from this content.
The keys of the hash table are the words, and the values tell
you what pages each word appears on. Now suppose a user
searches for hi. Let’s see what pages hi shows up on.


The Fourier transform
The Fourier transform is one of those rare algorithms: brilliant,
elegant, and with a million use cases. The best analogy for the Fourier
transform comes from Better Explained (a great website that explains
math simply): given a smoothie, the Fourier transform will tell you the
ingredients in the smoothie. 1 Or, to put it another way, given a song, the
transform can separate it into individual frequencies.

Parallel algorithms
The next three topics are about scalability and working with a lot of
data. Back in the day, computers kept getting faster and faster. If you
wanted to make your algorithm faster, you could wait a few months,
and the computers themselves would become faster. But we’re near the
end of that period. Instead, laptops and computers ship with multiple
cores. To make your algorithms faster, you need to change them to run
in parallel across all the cores at once!





MapReduce
There’s a special type of parallel algorithm that is becoming increasingly
popular: the distributed algorithm. It’s fine to run a parallel algorithm
on your laptop if you need two to four cores, but what if you need
hundreds of cores? Then you can write your algorithm to run across
multiple machines. The MapReduce algorithm is a popular distributed
algorithm. You can use it through the popular open source tool
Apache Hadoop


Bloom filters and HyperLogLog
Suppose you’re running Reddit. When someone posts a link, you want
to see if it’s been posted before. Stories that haven’t been posted before
are considered more valuable. So you need to figure out whether this
link has been posted before.
Or suppose you’re Google, and you’re crawling web pages. You only
want to crawl a web page if you haven’t crawled it already. So you need
to figure out whether this page has been crawled before.
Or suppose you’re running bit.ly, which is a URL shortener. You don’t
want to redirect users to malicious websites. You have a set of URLs that
are considered malicious. Now you need to

The SHA algorithms
Do you remember hashing from chapter 5? Just to recap, suppose you
have a key, and you want to put the associated value in an array.

Diffie-Hellman key exchange
The Diffie-Hellman algorithm deserves a mention here, because it solves
an age-old problem in an elegant way. How do you encrypt a m


Linear programming
I saved the best for last. Linear programming is one of the coolest
things I know.
Linear programming is used to maximize something given some
constraints. For example, suppose your company makes two products,
shirts and totes. Shirts need 1 meter of fabric and 5 buttons. Totes need
2 meters of fabric and 2 buttons. You have 11 meters of fabric and 20
buttons. You make $2 per shirt and $3 per tote. How many shirts and
totes should you make to maximize your profit?
