4.3	
Given a sorted (increasing order) array, write an algorithm to create a binary tree with
minimal height.
				
pg 54
SOLUTION
We will try to create a binary tree such that for each node, the number of nodes in the left
subtree and the right subtree are equal, if possible.
Algorithm:
1.	 Insert into the tree the middle element of the array.
2.	 Insert (into the left subtree) the left subarray elements
3.	 Insert (into the right subtree) the right subarray elements
4.	 Recurse

public static TreeNode addToTree(int arr[], int start, int end){
	if (end < start) {
		return null;
	}
	int mid = (start + end) / 2;
	TreeNode n = new TreeNode(arr[mid]);
	n.left = addToTree(arr, start, mid - 1);
	n.right = addToTree(arr, mid + 1, end);
	return n;
} 
public static TreeNode createMinimalBST(int array[]) { 
    return addToTree(array, 0, array.length - 1);
}

4.7	
You have two very large binary trees: T1, with millions of nodes, and T2, with hun-
dreds of nodes. Create an algorithm to decide if T2 is a subtree of T1.
					
pg 54
SOLUTION
Note that the problem here specifies that T1 has millions of nodes—this means that we
should be careful of how much space we use. Let’s say, for example, T1 has 10 million
nodes—this means that the data alone is about 40 mb. We could create a string representing
the inorder and preorder traversals. If T2’s preorder traversal is a substring of T1’s preorder
traversal, and T2’s inorder traversal is a substring of T1’s inorder traversal, then T2 is a sub-
string of T1. We can check this using a suffix tree. However, we may hit memory limitations
because suffix trees are extremely memory intensive. If this become an issue, we can use an
alternative approach.
Alternative Approach: The treeMatch procedure visits each node in the small tree at most
once and is called no more than once per node of the large tree. Worst case runtime is at
most O(n * m), where n and m are the sizes of trees T1 and T2, respectively. If k is the number
of occurrences of T2’s root in T1, the worst case runtime can be characterized as O(n + k * m).
boolean containsTree(TreeNode t1, TreeNode t2) {
	if (t2 == null) return true; // The empty tree is always a subtree
	else return subTree(t1, t2);
} boolean subTree(TreeNode r1, TreeNode r2) {
	if (r1 == null)
		return false; // big tree empty & subtree still not found.
	if (r1.data == r2.data) {
		if (matchTree(r1,r2)) return true;
	}
	return (subTree(r1.left, r2) || subTree(r1.right, r2));
} boolean matchTree(TreeNode r1, TreeNode r2) {
	if (r2 == null && r1 == null)
		return true; // nothing left in the subtree
	if (r1 == null || r2 == null)
		return false; // big tree empty & subtree still not found
	if (r1.data != r2.data)
		return false; // data doesn’t match
	return (matchTree(r1.left, r2.left) &&
			matchTree(r1.right, r2.right));
	}
}
