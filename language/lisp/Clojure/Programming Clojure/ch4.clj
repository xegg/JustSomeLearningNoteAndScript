(first '(1 2 3))
(rest '(1 2 3))
(cons 0 '(1 2 3))
(first [1 2 3])
(rest [1 2 3])
(cons 0 [1 2 3])
(class (rest [1 2 3]))
(first {:fname "Stu", :lname "Halloway"})
(rest {:fname "Stu", :lname "Halloway"})
(cons [:mname "Dabbs"] {:fname "Stu", :lname "Halloway"})
(first #{:the :quick :brown :fox})
(rest #{:the :quick :brown :fox})
(cons :jumped #{:the :quick :brown :fox})
#{:the :quick :brown :fox}
(sorted-set :the :quick :brown :fox)
{:a 1, :b 2, :c 3}
(sorted-map :c 3 :b 2 :a 1)
(conj '(1 2 3) :a)
(into '(1 2 3) '(:a :b :c))
(conj [1 2 3] :a)
(into [1 2 3] [:a :b :c])

(range 10)
(range 10 20)
(range 1 25 2)
(repeat 5 1)
(repeat 10 "x")
(take 10 (iterate inc 1))
(defn whole [] (iterate inc 1))
(take 20 (repeat 1))
(take 10 (cycle (range 3)))
(interleave (whole) ["A" "B" "C" "D" "E"])
(interpose "," ["a" "b" "g"])
(apply str (interpose "," ["a" "b" "g"]))
(use '[clojure.string :only (join)])
(join \, ["a" "b" "g"])
(set [1 2 3])
(hash-set 1 2 3)
(vec (range 3))
(take 10 (filter even? (whole)))
(take 10 (filter odd? (whole)))
(take-while (complement #{\a\e\i\o\u}) "the quick brown fox")
(drop-while (complement #{\a\e\i\o\u}) "the quick brown fox")
(split-at 5 (range 10))
(split-with #(<= % 10) (range 0 20 2))
(every? odd? [1 3 5])
(every? odd? [1 3 5 8])
(some even? [1 2 3])
(some even? [1 3 5])
(some identity [nil false 1 nil 2])
(not-every? even? (whole))
(not-any? even? (whole))
(map #(format "<p>%s</p>" %) ["the" "quick" "brown" "fox"])
(map #(format "<%s>%s</%s>" %1 %2 %1)
     ["h1" "h2" "h3" "h1"] ["the" "quick" "brown" "fox"])
(reduce + (range 1 11))
(reduce * (range 1 11))
(sort [42 1 7 11])
(sort-by #(.toString %) [42 1 7 11])
(sort > [42 1 7 11])
(sort-by :grade > [{:grade 83} {:grade 90} {:grade 77}])
(for [word ["the" "quick" "brown" "fox"]]
  (format "<p>%s</p>" word))
(take 10 (for [n (whole) :when (even? n)] n))
(for [n (whole) :while (even? n)] n)
(for [file "ABCDEFGH" rank (range 1 9)] (format "%c%d" file rank))
(for [rank (range 1 9) file "ABCDEFGH"] (format "%c%d" file rank))

(use '[clojure.contrib.lazy-seqs :only (primes)])
(def ords-and-primes (map vector (iterate inc 1) primes))
(take 5 (drop 1000 ords-and-primes))
(def x (for [i (range 1 3)] (do (println i) i)))
(doall x)
(def x (for [i (range 1 3)] (do (println i) i)))
(dorun x)

(first (.getBytes "hello"))
(rest (.getBytes "hello"))
(cons (int \h) (.getBytes "ello"))
(first (System/getProperties))
(rest (System/getProperties))
(first "Hello")
(rest "Hello")
(cons \H "ello")
(reverse "hello")
(apply str (reverse "hello"))
(let [m (re-matcher #"\w+" "the quick brown fox")]
  (loop [match (re-find m)]
    (when match
      (println match)
      (recur (re-find m)))))
(re-seq #"\w+" "the quick brown fox")
(sort (re-seq #"\w+" "the quick brown fox"))
(drop 2 (re-seq #"\w+" "the quick brown fox"))
(map #(.toUpperCase %) (re-seq #"\w+" "the quick brown fox"))
(import '(java.io File))
(.listFiles (File. "."))
(seq (.listFiles (File. ".")))
(map #(.getName %) (seq (.listFiles (File. "."))))
(map #(.getName %) (.listFiles (File. ".")))
(count (file-seq (File. ".")))
(defn minutes-to-millis [mins] (* mins 1000 60))
(defn recently-modified? [file]
  (> (.lastModified file)
     (- (System/currentTimeMillis) (minutes-to-millis 30))))
(filter recently-modified? (file-seq (File. ".")))
(use '[clojure.java.io :only (reader)])
(take 2 (line-seq (reader "examples/utils.clj")))
(with-open [rdr (reader "examples/utils.clj")]
  (count (line-seq rdr)))
(with-open [rdr (reader "examples/utils.clj")]
  (count (filter #(re-find #"\S" %) (line-seq rdr))))
(defn non-blank? [line] (if (re-find #"\S" line) true false))
(defn non-svn? [file] (not (.contains (.toString file) ".svn")))
(defn clojure-source? [file] (.endsWith (.toString file) ".clj"))
(defn clojure-loc [base-file]
  (reduce
   +
   (for [file (file-seq base-file)
	 :when (and (clojure-source? file) (non-svn? file))]
     (with-open [rdr (reader file)]
       (count (filter non-blank? (line-seq rdr)))))))
(clojure-loc (java.io.File. "examples"))
(use '[clojure.xml :only (parse)])
(parse (java.io.File. "examples/sequences/compositions.xml"))
(for [x (xml-seq
	 (parse (java.io.File. "examples/sequences/compositions.xml")))
      :when (= :composition (:tag x))]
  (:composer (:attrs x)))

(peek '(1 2 3))
(pop '(1 2 3))
(rest ())
(pop ())
(peek [1 2 3])
(pop [1 2 3])
(get [:a :b :c] 1)
(get [:a :b :c] 5)
([:a :b :c] 1)
([:a :b :c] 5)
(assoc [0 1 2 3 4] 2 :two)
(subvec [1 2 3 4 5] 3)
(subvec [1 2 3 4 5] 1 3)
(take 2 (drop 1 [1 2 3 4 5]))
(keys {:sundance "spaniel", :darwin "beagle"})
(vals {:sundance "spaniel", :darwin "beagle"})
(get {:sundance "spaniel", :darwin "beagle"} :darwin)
(get {:sundance "spaniel", :darwin "beagle"} :snoopy)
({:sundance "spaniel", :darwin "beagle"} :darwin)
({:sundance "spaniel", :darwin "beagle"} :snoopy)
(:darwin {:sundance "spaniel", :darwin "beagle"})
(:snoopy {:sundance "spaniel", :darwin "beagle"})
(def score {:stu nil, :joey 100})
(contains? score :stu)
(get score :stu :score-not-found)
(get score :aaron :score-not-found)
(def song {:name "agnus dei"
	   :artist "K P"
	   :album "polish requiem"
	   :genre "classical"})
(assoc song :kind "MPEG")
(dissoc song :genre)
(select-keys song [:name :artist])
(merge song {:size 8118166, :time 507245})
(merge-with
 concat
 {:rubble ["barney"], :flintstone ["fred"]}
 {:rubble ["betty"], :flintstone ["wilma"]}
 {:rubble ["bam-bam"], :flintstone ["pebbles"]})
(use 'clojure.set)
(def languages #{"java" "c" "d" "clojure"})
(def letters #{"a" "b" "c" "d" "e"})
(def beverages #{"java" "chai" "pop"})
(union languages beverages)
(difference languages beverages)
(intersection languages beverages)
(select #(= 1 (.length %)) languages)
(def compositions
     #{{:name "art of fugue", :composer "bach"}
       {:name "musical offering" :composer "bach"}
       {:name "requiem", :composer "verdi"}
       {:name "requiem", :composer "mozart"}})
(def composers
     #{{:composer "bach", :country "germany"}
       {:composer "mozart", :country "austria"}
       {:composer "verdi", :country "italy"}})
(def nations
     #{{:nation "germany", :language "german"}
       {:nation "austria", :language "german"}
       {:nation "italy", :language "italian"}})
(rename compositions {:name :title})
(select #(= (:name %) "requiem") compositions)
(project compositions [:name])
(for [m compositions c composers] (concat m c))
(join compositions composers)
(join composers nations {:country :nation})
(project
 (join (select #(= (:name %) "requiem") compositions)
       composers)
 [:country])
